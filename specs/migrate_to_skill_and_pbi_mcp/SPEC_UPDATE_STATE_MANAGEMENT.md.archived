# SPEC Update: Zero-Dependency State Management with Fallback

**Date:** 2025-12-22
**Status:** Draft Amendment to SPEC.md
**Replaces:** Section 7.0.8 (State Management Patterns), Section 7.0.9 (Distribution Strategy)

---

## Overview

This amendment removes Python as a core dependency and implements a **capability-based fallback strategy** for state management. The skill attempts Claude-native operations first, then falls back to PowerShell, then to CMD.

**Key Changes:**
1. Python removed from core requirements (now optional for telemetry addon)
2. State management via Claude's native Read/Write/Edit tools (preferred)
3. PowerShell fallback for environments where Claude-native fails
4. CMD minimal fallback as last resort
5. Telemetry delivered as an optional addon instruction
6. Compatibility header for future tool support (Copilot, etc.)

---

## 1. Revised Dependency Model

### 1.1 Core Dependencies (Required)

| Dependency | Version | Purpose | Built-In |
|------------|---------|---------|----------|
| **Claude Code** | 1.0+ | Skill execution, file operations | Yes |
| **PowerShell** | 5.1+ | Fallback state management | Yes (Windows 10+) |
| **Power BI Modeling MCP** | Latest | Semantic model operations | No (download) |

### 1.2 Optional Dependencies (Addons)

| Dependency | Version | Purpose | Addon |
|------------|---------|---------|-------|
| **Python** | 3.10+ | Telemetry, advanced validation | `telemetry.md` |
| **opentelemetry-sdk** | 1.20+ | Trace export | `telemetry.md` |
| **arize-phoenix** | 4.0+ | Observability dashboard | `telemetry.md` |
| **pydantic** | 2.0+ | Schema validation | `validation.md` |

### 1.3 Removed from Core

| Previously Required | Replacement |
|---------------------|-------------|
| Python 3.10+ | Claude-native or PowerShell |
| pathlib | Claude Read/Write tools |
| pydantic | Optional addon |
| state_manage.py | Claude-native + state_manage.ps1 fallback |

---

## 2. State Management Architecture

### 2.1 Capability Detection Protocol

The skill detects available capabilities **once per session** and stores the result.

```
SESSION START
    │
    ▼
┌─────────────────────────────────────────────────────────────────┐
│  CAPABILITY PROBE (Run Once)                                     │
│  ─────────────────────────────                                   │
│  Goal: Determine best available state management backend         │
└─────────────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────────────┐
│  Test 1: Claude-Native JSON Capability                           │
│  ─────────────────────────────────────                           │
│  1. Create test file: .claude/capability_probe.json              │
│     Content: {"probe": "test", "timestamp": 0}                   │
│  2. Read the file back                                           │
│  3. Parse JSON, update timestamp to current time                 │
│  4. Write updated JSON                                           │
│  5. Read again, verify timestamp changed                         │
│                                                                  │
│  SUCCESS → state_backend = "claude_native"                       │
│  FAILURE → Continue to Test 2                                    │
└─────────────────────────────────────────────────────────────────┘
    │ (if failed)
    ▼
┌─────────────────────────────────────────────────────────────────┐
│  Test 2: PowerShell Capability                                   │
│  ─────────────────────────────                                   │
│  Execute: powershell -Command "Write-Output 'PROBE_OK'"          │
│                                                                  │
│  If output contains "PROBE_OK":                                  │
│      → state_backend = "powershell"                              │
│  Else:                                                           │
│      → Continue to Test 3                                        │
└─────────────────────────────────────────────────────────────────┘
    │ (if failed)
    ▼
┌─────────────────────────────────────────────────────────────────┐
│  Test 3: CMD Capability (Windows)                                │
│  ─────────────────────────────────                               │
│  Execute: cmd /c "echo PROBE_OK"                                 │
│                                                                  │
│  If output contains "PROBE_OK":                                  │
│      → state_backend = "cmd"                                     │
│  Else:                                                           │
│      → Continue to Test 4                                        │
└─────────────────────────────────────────────────────────────────┘
    │ (if failed)
    ▼
┌─────────────────────────────────────────────────────────────────┐
│  Test 4: Bash + jq Capability (macOS/Linux)                      │
│  ─────────────────────────────────────────                       │
│  Execute: bash -c "command -v jq && echo PROBE_OK"               │
│                                                                  │
│  If output contains "PROBE_OK":                                  │
│      → state_backend = "bash"                                    │
│  Else:                                                           │
│      → state_backend = "none" (ERROR STATE - warn user)          │
└─────────────────────────────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────────────────────────────┐
│  Store Result in Session State                                   │
│  ─────────────────────────────                                   │
│  Write to .claude/state.json:                                    │
│  {                                                               │
│    "session": {                                                  │
│      "state_backend": "claude_native|powershell|cmd|bash",       │
│      "capability_probe": {                                       │
│        "tested_at": "2025-12-22T10:00:00Z",                      │
│        "claude_native": true|false,                              │
│        "powershell": true|false,                                 │
│        "cmd": true|false,                                        │
│        "bash": true|false                                        │
│      }                                                           │
│    }                                                             │
│  }                                                               │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 Backend-Specific Operations

Each state operation has three implementations. The skill uses the detected backend.

#### 2.2.1 Create Task

**Claude-Native Mode:**
```markdown
1. Generate task ID:
   - Format: `<sanitized_name>-<unix_timestamp>`
   - Example: `fix-yoy-calc-1734872400`

2. Create task directory:
   - Use Bash tool: `mkdir -p .claude/tasks/<task_id>`

3. Read current state:
   - Use Read tool on `.claude/state.json`
   - Parse as JSON (Claude can do this natively)

4. Update state:
   - Add entry to `active_tasks` object:
     ```json
     {
       "active_tasks": {
         "<task_id>": {
           "path": ".claude/tasks/<task_id>",
           "status": "in_progress",
           "workflow_type": "<workflow>",
           "created": "<ISO_timestamp>"
         }
       }
     }
     ```

5. Write updated state:
   - Use Write tool to save `.claude/state.json`

6. Create findings.md:
   - Use Write tool to create `.claude/tasks/<task_id>/findings.md`
   - Initialize with template from Section 2.4

7. Return task_id
```

**PowerShell Mode:**
```bash
powershell -ExecutionPolicy Bypass -File .claude/tools/state_manage.ps1 -CreateTask "<name>" -Workflow "<workflow_type>"
```

**CMD Mode:**
```bash
.claude\tools\state_manage.cmd create_task "<name>" "<workflow_type>"
```

---

#### 2.2.2 Acquire Lock

**Claude-Native Mode:**
```markdown
1. Read `.claude/state.json`

2. Check existing locks:
   - Look for `resource_locks["<resource_path>"]`
   - If exists AND value != current task_id:
     - Return: `LOCKED_BY:<owner_task_id>`
   - If exists AND value == current task_id:
     - Return: `OK` (already own lock)

3. If not locked:
   - Add entry: `resource_locks["<resource_path>"] = "<task_id>"`
   - Update `session.last_activity` timestamp
   - Write state.json

4. Return: `OK`
```

**PowerShell Mode:**
```bash
powershell -ExecutionPolicy Bypass -File .claude/tools/state_manage.ps1 -Lock "<resource_path>" -TaskId "<task_id>"
```

**CMD Mode:**
```bash
.claude\tools\state_manage.cmd lock "<resource_path>" "<task_id>"
```

---

#### 2.2.3 Release Lock

**Claude-Native Mode:**
```markdown
1. Read `.claude/state.json`

2. Check lock ownership:
   - If `resource_locks["<resource_path>"]` != task_id:
     - Return: `ERROR:NOT_OWNER`

3. Remove lock:
   - Delete `resource_locks["<resource_path>"]`
   - Write state.json

4. Return: `OK`
```

**PowerShell Mode:**
```bash
powershell -ExecutionPolicy Bypass -File .claude/tools/state_manage.ps1 -Release "<resource_path>" -TaskId "<task_id>"
```

---

#### 2.2.4 Complete Task

**Claude-Native Mode:**
```markdown
1. Read `.claude/state.json`

2. Update task status:
   - Set `active_tasks[<task_id>].status = "completed"`
   - Set `active_tasks[<task_id>].completed_at = <ISO_timestamp>`

3. Release all locks owned by this task:
   - For each lock in `resource_locks`:
     - If value == task_id: delete entry

4. Write state.json

5. Return: `OK`
```

---

#### 2.2.5 Archive Task

**Claude-Native Mode:**
```markdown
1. Read `.claude/state.json`

2. Get task data from `active_tasks[<task_id>]`

3. Create archive entry:
   ```json
   {
     "task_id": "<task_id>",
     "workflow_type": "<workflow>",
     "completed_at": "<timestamp>",
     "summary": "<brief_summary>"
   }
   ```

4. Add to `archived_tasks[]` array

5. Remove from `active_tasks`

6. Ensure all locks released

7. Write state.json

8. Return: `OK`
```

---

### 2.3 State Schema (Complete)

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Power BI Analyst Skill State",
  "type": "object",
  "properties": {
    "session": {
      "type": "object",
      "properties": {
        "started": { "type": "string", "format": "date-time" },
        "last_activity": { "type": "string", "format": "date-time" },
        "skill_version": { "type": "string" },
        "state_backend": {
          "type": "string",
          "enum": ["claude_native", "powershell", "cmd", "bash", "none"]
        },
        "capability_probe": {
          "type": "object",
          "properties": {
            "tested_at": { "type": "string", "format": "date-time" },
            "claude_native": { "type": "boolean" },
            "powershell": { "type": "boolean" },
            "cmd": { "type": "boolean" },
            "bash": { "type": "boolean" }
          }
        },
        "mcp_available": { "type": "boolean" },
        "connection": {
          "type": "object",
          "properties": {
            "type": { "type": "string", "enum": ["desktop", "fabric", "pbip", "file_fallback"] },
            "status": { "type": "string", "enum": ["connected", "disconnected", "error"] },
            "established_at": { "type": "string", "format": "date-time" }
          }
        }
      },
      "required": ["started", "state_backend"]
    },
    "model_schema": {
      "type": "object",
      "properties": {
        "tables": { "type": "array" },
        "relationships": { "type": "array" },
        "last_synced": { "type": "string", "format": "date-time" },
        "sync_source": { "type": "string", "enum": ["mcp", "tmdl_parse"] }
      }
    },
    "active_tasks": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "properties": {
          "path": { "type": "string" },
          "status": { "type": "string", "enum": ["pending", "in_progress", "completed", "failed"] },
          "workflow_type": { "type": "string" },
          "created": { "type": "string", "format": "date-time" },
          "updated": { "type": "string", "format": "date-time" },
          "current_stage": { "type": "string" }
        },
        "required": ["path", "status", "workflow_type", "created"]
      }
    },
    "resource_locks": {
      "type": "object",
      "additionalProperties": { "type": "string" }
    },
    "archived_tasks": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "task_id": { "type": "string" },
          "workflow_type": { "type": "string" },
          "completed_at": { "type": "string", "format": "date-time" },
          "summary": { "type": "string" }
        }
      }
    }
  },
  "required": ["session", "active_tasks", "resource_locks"]
}
```

### 2.4 Findings Template (Task Blackboard)

```markdown
# Task Blackboard: [TASK_NAME]

**Status:** [pending|in_progress|completed|failed]
**Task ID:** [TASK_ID]
**Workflow:** [evaluate|create_artifact|create_page|implement|analyze|merge]
**Created:** [ISO_TIMESTAMP]
**Backend:** [claude_native|powershell|cmd]

---

## Section 1: Requirements
*Written by: Orchestrator (skill.md)*

### 1.1 User Request
> [Original user request verbatim]

### 1.2 Clarified Goal
- **Objective:** [Clear statement of what needs to be accomplished]
- **Success Criteria:** [How we know it's done]

### 1.3 Artifacts Needed
- [ ] [Artifact Type]: [Name] → [Specialist]
- [ ] [Artifact Type]: [Name] → [Specialist]

### 1.4 Model Schema Context
*From state.json model_schema or MCP query*

**Relevant Tables:**
| Table | Columns | Measures |
|-------|---------|----------|
| [Name] | [List] | [List] |

**Relevant Relationships:**
- [From] → [To] ([Cardinality])

---

## Section 2: DAX Logic
*Written by: powerbi-dax-specialist*

### 2.1 Measures

#### [Measure Name]

**Change Type:** CREATE | MODIFY | DELETE
**Target Table:** [Table Name]

**Proposed Code:**
```dax
[Measure Name] =
VAR CurrentValue = [Expression]
RETURN
    DIVIDE(CurrentValue, [Denominator])
```

**Metadata:**
- **Format String:** `"0.0%"`
- **Display Folder:** `"Folder Name"`
- **Description:** `"Business description"`

**Validation:**
- [ ] Syntax validated (MCP/manual)
- [ ] References verified
- [ ] Edge cases handled

**Dependencies:**
- Requires: [List of dependencies]

---

## Section 3: M-Code Logic
*Written by: powerbi-mcode-specialist*

### 3.1 Partitions

#### [Partition Name]

**Change Type:** CREATE | MODIFY
**Target Table:** [Table Name]

**Proposed Code:**
```m
let
    Source = [Expression],
    Result = [Transformations]
in
    Result
```

**Metadata:**
- **Privacy Level:** Organizational | Private | Public
- **Mode:** Import | DirectQuery

**Query Folding:**
| Step | Folds? | Notes |
|------|--------|-------|
| [Step] | Yes/No | [Notes] |

---

## Section 4: PBIR Logic
*Written by: Orchestrator (PBIR agents)*

### 4.1 Visual Changes

#### [Visual Name]

**Change Type:** CREATE | MODIFY
**Page:** [Page Name]
**Visual Type:** [Type]

**Layout:**
- Position: (x, y)
- Size: width x height

**Data Bindings:**
```json
{
  "measure": "[Measure Name]",
  "dimension": "[Column Name]"
}
```

---

## Section 5: Implementation Plan
*Written by: Orchestrator after specialist sections complete*

### 5.1 Execution Order

1. [ ] [Operation]: [File] - [Description]
2. [ ] [Operation]: [File] - [Description]

### 5.2 Rollback Strategy

- Versioned copy at: [Path]
- Transaction ID: [If MCP]

---

## Section 6: Validation Results
*Written by: Validation agents*

### 6.1 DAX Validation
- **Status:** [Passed|Failed|Skipped]
- **Method:** [MCP|Manual Review]
- **Issues:** [List or "None"]

### 6.2 TMDL Validation
- **Status:** [Passed|Failed|Skipped]
- **Issues:** [List or "None"]

### 6.3 PBIR Validation
- **Status:** [Passed|Failed|Skipped]
- **Issues:** [List or "None"]

---

## Section 7: Test Cases
*Written by: power-bi-verification*

### TC-001: [Test Name]
- **Type:** Visual | Calculation | Interaction
- **Steps:** [Numbered steps]
- **Expected:** [Expected result]

---

## Section 8: Execution Log
*Written by: Orchestrator during implementation*

| Timestamp | Operation | Status | Notes |
|-----------|-----------|--------|-------|
| [Time] | [Op] | [OK/FAIL] | [Notes] |

---

## Section 9: Summary
*Written by: Orchestrator on completion*

### Before
```dax
[Previous code or "N/A for new artifacts"]
```

### After
```dax
[New code]
```

### Result
[Brief description of what was accomplished]
```

---

## 3. Fallback Scripts

### 3.1 PowerShell Script (state_manage.ps1)

Location: `.claude/tools/state_manage.ps1`

```powershell
#Requires -Version 5.1
<#
.SYNOPSIS
    State management for Power BI Analyst Skill (PowerShell fallback)
.DESCRIPTION
    Used when Claude-native JSON operations are not available.
    Manages state.json, task lifecycle, and resource locks.
#>

[CmdletBinding()]
param(
    # Session operations
    [switch]$Summary,
    [switch]$RefreshSchema,
    [switch]$Reset,

    # Task operations
    [string]$CreateTask,
    [string]$Workflow,
    [string]$UpdateStage,
    [string]$Complete,
    [string]$Fail,
    [string]$Archive,
    [switch]$ListTasks,

    # Lock operations
    [string]$Lock,
    [string]$Release,
    [string]$TaskId,
    [switch]$ListLocks,
    [string]$ForceRelease,

    # Schema operations
    [switch]$GetSchema,
    [string]$SetSchema
)

# Configuration
$StatePath = ".claude\state.json"
$TasksDir = ".claude\tasks"

# Helper: Load or initialize state
function Get-State {
    if (Test-Path $StatePath) {
        try {
            $content = Get-Content $StatePath -Raw -Encoding UTF8
            return $content | ConvertFrom-Json -AsHashtable
        }
        catch {
            Write-Warning "Failed to parse state.json, initializing fresh state"
        }
    }

    # Initialize default state
    return @{
        session = @{
            started = (Get-Date -Format "o")
            last_activity = (Get-Date -Format "o")
            skill_version = "1.0.0"
            state_backend = "powershell"
            mcp_available = $false
        }
        model_schema = @{
            tables = @()
            relationships = @()
        }
        active_tasks = @{}
        resource_locks = @{}
        archived_tasks = @()
    }
}

# Helper: Save state
function Save-State {
    param([hashtable]$State)

    $State.session.last_activity = (Get-Date -Format "o")

    # Ensure directory exists
    $dir = Split-Path $StatePath -Parent
    if (-not (Test-Path $dir)) {
        New-Item -ItemType Directory -Path $dir -Force | Out-Null
    }

    $State | ConvertTo-Json -Depth 10 | Set-Content $StatePath -Encoding UTF8
}

# Helper: Generate task ID
function New-TaskId {
    param([string]$Name)

    $sanitized = $Name -replace '[^a-zA-Z0-9\-]', '-' -replace '-+', '-'
    $timestamp = [DateTimeOffset]::UtcNow.ToUnixTimeSeconds()
    return "$sanitized-$timestamp"
}

# ============================================================
# SESSION OPERATIONS
# ============================================================

if ($Summary) {
    $state = Get-State

    $output = @{
        session_started = $state.session.started
        last_activity = $state.session.last_activity
        state_backend = $state.session.state_backend
        mcp_available = $state.session.mcp_available
        active_task_count = $state.active_tasks.Count
        lock_count = $state.resource_locks.Count
        archived_count = $state.archived_tasks.Count
    }

    $output | ConvertTo-Json
    exit 0
}

if ($Reset) {
    if (Test-Path $StatePath) {
        Remove-Item $StatePath -Force
    }
    Write-Output "State reset complete"
    exit 0
}

# ============================================================
# TASK OPERATIONS
# ============================================================

if ($CreateTask) {
    $state = Get-State
    $taskId = New-TaskId -Name $CreateTask
    $taskPath = Join-Path $TasksDir $taskId

    # Create task directory
    New-Item -ItemType Directory -Path $taskPath -Force | Out-Null

    # Create empty findings.md
    $findingsPath = Join-Path $taskPath "findings.md"
    @"
# Task Blackboard: $CreateTask

**Status:** in_progress
**Task ID:** $taskId
**Workflow:** $Workflow
**Created:** $(Get-Date -Format "o")
**Backend:** powershell

---

## Section 1: Requirements
*Pending...*
"@ | Set-Content $findingsPath -Encoding UTF8

    # Update state
    $state.active_tasks[$taskId] = @{
        path = $taskPath
        status = "in_progress"
        workflow_type = $Workflow
        created = (Get-Date -Format "o")
        updated = (Get-Date -Format "o")
        current_stage = "init"
    }

    Save-State $state

    # Return task ID
    Write-Output $taskId
    exit 0
}

if ($UpdateStage -and $TaskId) {
    $state = Get-State

    if (-not $state.active_tasks.ContainsKey($TaskId)) {
        Write-Error "Task not found: $TaskId"
        exit 1
    }

    $state.active_tasks[$TaskId].current_stage = $UpdateStage
    $state.active_tasks[$TaskId].updated = (Get-Date -Format "o")

    Save-State $state
    Write-Output "OK"
    exit 0
}

if ($Complete) {
    $state = Get-State

    if (-not $state.active_tasks.ContainsKey($Complete)) {
        Write-Error "Task not found: $Complete"
        exit 1
    }

    $state.active_tasks[$Complete].status = "completed"
    $state.active_tasks[$Complete].completed_at = (Get-Date -Format "o")

    # Release all locks owned by this task
    $locksToRelease = @()
    foreach ($lock in $state.resource_locks.GetEnumerator()) {
        if ($lock.Value -eq $Complete) {
            $locksToRelease += $lock.Key
        }
    }
    foreach ($lock in $locksToRelease) {
        $state.resource_locks.Remove($lock)
    }

    Save-State $state
    Write-Output "OK"
    exit 0
}

if ($Fail) {
    $state = Get-State

    if (-not $state.active_tasks.ContainsKey($Fail)) {
        Write-Error "Task not found: $Fail"
        exit 1
    }

    $state.active_tasks[$Fail].status = "failed"
    $state.active_tasks[$Fail].failed_at = (Get-Date -Format "o")

    Save-State $state
    Write-Output "OK"
    exit 0
}

if ($Archive) {
    $state = Get-State

    if (-not $state.active_tasks.ContainsKey($Archive)) {
        Write-Error "Task not found: $Archive"
        exit 1
    }

    $task = $state.active_tasks[$Archive]

    # Create archive entry
    $archiveEntry = @{
        task_id = $Archive
        workflow_type = $task.workflow_type
        completed_at = if ($task.completed_at) { $task.completed_at } else { Get-Date -Format "o" }
        status = $task.status
    }

    $state.archived_tasks += $archiveEntry
    $state.active_tasks.Remove($Archive)

    # Release any remaining locks
    $locksToRelease = @()
    foreach ($lock in $state.resource_locks.GetEnumerator()) {
        if ($lock.Value -eq $Archive) {
            $locksToRelease += $lock.Key
        }
    }
    foreach ($lock in $locksToRelease) {
        $state.resource_locks.Remove($lock)
    }

    Save-State $state
    Write-Output "OK"
    exit 0
}

if ($ListTasks) {
    $state = Get-State
    $state.active_tasks | ConvertTo-Json -Depth 5
    exit 0
}

# ============================================================
# LOCK OPERATIONS
# ============================================================

if ($Lock -and $TaskId) {
    $state = Get-State

    # Check if already locked by another task
    if ($state.resource_locks.ContainsKey($Lock)) {
        $owner = $state.resource_locks[$Lock]
        if ($owner -ne $TaskId) {
            Write-Output "LOCKED:$owner"
            exit 1
        }
        # Already own the lock
        Write-Output "OK"
        exit 0
    }

    # Acquire lock
    $state.resource_locks[$Lock] = $TaskId
    Save-State $state
    Write-Output "OK"
    exit 0
}

if ($Release -and $TaskId) {
    $state = Get-State

    if (-not $state.resource_locks.ContainsKey($Release)) {
        Write-Output "OK"  # Not locked, nothing to release
        exit 0
    }

    $owner = $state.resource_locks[$Release]
    if ($owner -ne $TaskId) {
        Write-Error "Cannot release lock owned by: $owner"
        exit 1
    }

    $state.resource_locks.Remove($Release)
    Save-State $state
    Write-Output "OK"
    exit 0
}

if ($ForceRelease) {
    $state = Get-State

    if ($state.resource_locks.ContainsKey($ForceRelease)) {
        $state.resource_locks.Remove($ForceRelease)
        Save-State $state
    }

    Write-Output "OK"
    exit 0
}

if ($ListLocks) {
    $state = Get-State
    $state.resource_locks | ConvertTo-Json
    exit 0
}

# ============================================================
# SCHEMA OPERATIONS
# ============================================================

if ($GetSchema) {
    $state = Get-State
    $state.model_schema | ConvertTo-Json -Depth 10
    exit 0
}

if ($SetSchema) {
    $state = Get-State

    try {
        $schema = $SetSchema | ConvertFrom-Json -AsHashtable
        $state.model_schema = $schema
        $state.model_schema.last_synced = (Get-Date -Format "o")
        Save-State $state
        Write-Output "OK"
    }
    catch {
        Write-Error "Invalid JSON schema"
        exit 1
    }
    exit 0
}

# No operation specified
Write-Host @"
Power BI Analyst Skill - State Manager (PowerShell)

Usage:
  state_manage.ps1 -Summary                    Show state summary
  state_manage.ps1 -CreateTask "name" -Workflow "type"   Create task
  state_manage.ps1 -UpdateStage "stage" -TaskId "id"     Update stage
  state_manage.ps1 -Complete "task_id"         Mark complete
  state_manage.ps1 -Fail "task_id"             Mark failed
  state_manage.ps1 -Archive "task_id"          Archive task
  state_manage.ps1 -ListTasks                  List active tasks
  state_manage.ps1 -Lock "path" -TaskId "id"   Acquire lock
  state_manage.ps1 -Release "path" -TaskId "id" Release lock
  state_manage.ps1 -ListLocks                  List all locks
  state_manage.ps1 -GetSchema                  Get model schema
  state_manage.ps1 -Reset                      Reset all state
"@
```

### 3.2 CMD Script (state_manage.cmd)

Location: `.claude/tools/state_manage.cmd`

```batch
@echo off
setlocal enabledelayedexpansion

REM ============================================================
REM Power BI Analyst Skill - State Manager (CMD Minimal Fallback)
REM ============================================================
REM This is a minimal fallback when PowerShell is unavailable.
REM Only supports essential operations.
REM ============================================================

set ACTION=%1
set ARG1=%2
set ARG2=%3

set STATE_PATH=.claude\state.json
set TASKS_DIR=.claude\tasks

REM Ensure .claude directory exists
if not exist ".claude" mkdir ".claude"

REM ============================================================
REM CREATE_TASK: Creates a new task directory and ID
REM ============================================================
if "%ACTION%"=="create_task" (
    REM Generate timestamp-based task ID
    for /f %%a in ('powershell -Command "[DateTimeOffset]::UtcNow.ToUnixTimeSeconds()"') do set TIMESTAMP=%%a

    REM Sanitize task name (basic)
    set TASK_NAME=%ARG1%
    set TASK_NAME=!TASK_NAME: =-!

    set TASK_ID=!TASK_NAME!-!TIMESTAMP!
    set TASK_PATH=!TASKS_DIR!\!TASK_ID!

    REM Create task directory
    mkdir "!TASK_PATH!" 2>nul

    REM Create minimal findings.md
    echo # Task: %ARG1% > "!TASK_PATH!\findings.md"
    echo. >> "!TASK_PATH!\findings.md"
    echo **Task ID:** !TASK_ID! >> "!TASK_PATH!\findings.md"
    echo **Workflow:** %ARG2% >> "!TASK_PATH!\findings.md"
    echo **Status:** in_progress >> "!TASK_PATH!\findings.md"

    echo !TASK_ID!
    exit /b 0
)

REM ============================================================
REM SUMMARY: Show basic state info
REM ============================================================
if "%ACTION%"=="summary" (
    if exist "%STATE_PATH%" (
        echo State file exists: %STATE_PATH%
        REM Count task directories
        set /a TASK_COUNT=0
        for /d %%d in ("%TASKS_DIR%\*") do set /a TASK_COUNT+=1
        echo Active task directories: !TASK_COUNT!
    ) else (
        echo No state file found
    )
    exit /b 0
)

REM ============================================================
REM HELP: Show usage
REM ============================================================
if "%ACTION%"=="help" (
    echo.
    echo Power BI Analyst Skill - State Manager (CMD Fallback)
    echo.
    echo Usage:
    echo   state_manage.cmd create_task "name" "workflow"
    echo   state_manage.cmd summary
    echo   state_manage.cmd help
    echo.
    echo Note: This is a minimal fallback. For full functionality,
    echo use the PowerShell version (state_manage.ps1).
    echo.
    exit /b 0
)

REM Unknown action
echo Unknown action: %ACTION%
echo Use 'state_manage.cmd help' for usage.
exit /b 1
```

### 3.3 Bash Script (state_manage.sh)

Location: `.claude/tools/state_manage.sh`

For macOS/Linux users, this bash script provides equivalent functionality using jq for JSON processing.

```bash
#!/usr/bin/env bash
#
# Power BI Analyst Skill - State Manager (Bash + jq Fallback)
#
# Used when Claude-native JSON operations and PowerShell are not available.
# Requires: jq (JSON processor)
#
# Usage:
#   state_manage.sh summary                       - Show state summary
#   state_manage.sh create_task "name" "workflow" - Create new task
#   state_manage.sh update_stage "task_id" "stage" - Update task stage
#   state_manage.sh complete "task_id"            - Mark task completed
#   state_manage.sh fail "task_id"                - Mark task failed
#   state_manage.sh archive "task_id"             - Archive task
#   state_manage.sh list_tasks                    - List active tasks
#   state_manage.sh lock "path" "task_id"         - Acquire lock
#   state_manage.sh release "path" "task_id"      - Release lock
#   state_manage.sh list_locks                    - List all locks
#   state_manage.sh get_schema                    - Get model schema
#   state_manage.sh reset                         - Reset all state
#

set -euo pipefail

# Configuration
STATE_PATH=".claude/state.json"
TASKS_DIR=".claude/tasks"

# ============================================================
# HELPER FUNCTIONS
# ============================================================

check_jq() {
    if ! command -v jq &> /dev/null; then
        echo "ERROR: jq is required but not installed."
        echo "Install jq:"
        echo "  macOS:   brew install jq"
        echo "  Ubuntu:  sudo apt-get install jq"
        echo "  Alpine:  apk add jq"
        exit 1
    fi
}

iso_timestamp() {
    date -u +"%Y-%m-%dT%H:%M:%SZ"
}

unix_timestamp() {
    date +%s
}

sanitize_name() {
    echo "$1" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g' | sed 's/-\+/-/g'
}

# Initialize state file if it doesn't exist
init_state() {
    mkdir -p "$(dirname "$STATE_PATH")"

    if [[ ! -f "$STATE_PATH" ]]; then
        cat > "$STATE_PATH" << EOF
{
  "session": {
    "started": "$(iso_timestamp)",
    "last_activity": "$(iso_timestamp)",
    "skill_version": "1.0.0",
    "state_backend": "bash",
    "mcp_available": false
  },
  "model_schema": {
    "tables": [],
    "relationships": []
  },
  "active_tasks": {},
  "resource_locks": {},
  "archived_tasks": []
}
EOF
    fi
}

# Get state JSON
get_state() {
    init_state
    cat "$STATE_PATH"
}

# Save state JSON (expects JSON on stdin)
save_state() {
    # Update last_activity timestamp
    jq --arg ts "$(iso_timestamp)" '.session.last_activity = $ts' > "$STATE_PATH.tmp"
    mv "$STATE_PATH.tmp" "$STATE_PATH"
}

# ============================================================
# SESSION OPERATIONS
# ============================================================

cmd_summary() {
    init_state
    local state
    state=$(get_state)

    local started last_activity backend mcp_avail task_count lock_count archive_count
    started=$(echo "$state" | jq -r '.session.started // "unknown"')
    last_activity=$(echo "$state" | jq -r '.session.last_activity // "unknown"')
    backend=$(echo "$state" | jq -r '.session.state_backend // "bash"')
    mcp_avail=$(echo "$state" | jq -r '.session.mcp_available // false')
    task_count=$(echo "$state" | jq '.active_tasks | length')
    lock_count=$(echo "$state" | jq '.resource_locks | length')
    archive_count=$(echo "$state" | jq '.archived_tasks | length')

    cat << EOF
{
  "session_started": "$started",
  "last_activity": "$last_activity",
  "state_backend": "$backend",
  "mcp_available": $mcp_avail,
  "active_task_count": $task_count,
  "lock_count": $lock_count,
  "archived_count": $archive_count
}
EOF
}

cmd_reset() {
    if [[ -f "$STATE_PATH" ]]; then
        rm -f "$STATE_PATH"
    fi
    echo "State reset complete"
}

# ============================================================
# TASK OPERATIONS
# ============================================================

cmd_create_task() {
    local name="$1"
    local workflow="${2:-evaluate}"

    init_state

    local sanitized task_id task_path timestamp
    sanitized=$(sanitize_name "$name")
    timestamp=$(unix_timestamp)
    task_id="${sanitized}-${timestamp}"
    task_path="${TASKS_DIR}/${task_id}"

    # Create task directory
    mkdir -p "$task_path"

    # Create findings.md
    cat > "${task_path}/findings.md" << EOF
# Task Blackboard: $name

**Status:** in_progress
**Task ID:** $task_id
**Workflow:** $workflow
**Created:** $(iso_timestamp)
**Backend:** bash

---

## Section 1: Requirements
*Pending...*
EOF

    # Update state
    local state
    state=$(get_state)

    echo "$state" | jq \
        --arg id "$task_id" \
        --arg path "$task_path" \
        --arg workflow "$workflow" \
        --arg created "$(iso_timestamp)" \
        '.active_tasks[$id] = {
            "path": $path,
            "status": "in_progress",
            "workflow_type": $workflow,
            "created": $created,
            "updated": $created,
            "current_stage": "init"
        }' | save_state

    echo "$task_id"
}

cmd_update_stage() {
    local task_id="$1"
    local stage="$2"

    local state
    state=$(get_state)

    # Check if task exists
    if ! echo "$state" | jq -e ".active_tasks[\"$task_id\"]" > /dev/null 2>&1; then
        echo "ERROR: Task not found: $task_id" >&2
        exit 1
    fi

    echo "$state" | jq \
        --arg id "$task_id" \
        --arg stage "$stage" \
        --arg ts "$(iso_timestamp)" \
        '.active_tasks[$id].current_stage = $stage | .active_tasks[$id].updated = $ts' | save_state

    echo "OK"
}

cmd_complete() {
    local task_id="$1"

    local state
    state=$(get_state)

    # Check if task exists
    if ! echo "$state" | jq -e ".active_tasks[\"$task_id\"]" > /dev/null 2>&1; then
        echo "ERROR: Task not found: $task_id" >&2
        exit 1
    fi

    # Mark complete and release locks
    echo "$state" | jq \
        --arg id "$task_id" \
        --arg ts "$(iso_timestamp)" \
        '.active_tasks[$id].status = "completed"
         | .active_tasks[$id].completed_at = $ts
         | .resource_locks = (.resource_locks | to_entries | map(select(.value != $id)) | from_entries)' | save_state

    echo "OK"
}

cmd_fail() {
    local task_id="$1"

    local state
    state=$(get_state)

    # Check if task exists
    if ! echo "$state" | jq -e ".active_tasks[\"$task_id\"]" > /dev/null 2>&1; then
        echo "ERROR: Task not found: $task_id" >&2
        exit 1
    fi

    echo "$state" | jq \
        --arg id "$task_id" \
        --arg ts "$(iso_timestamp)" \
        '.active_tasks[$id].status = "failed" | .active_tasks[$id].failed_at = $ts' | save_state

    echo "OK"
}

cmd_archive() {
    local task_id="$1"

    local state
    state=$(get_state)

    # Check if task exists
    if ! echo "$state" | jq -e ".active_tasks[\"$task_id\"]" > /dev/null 2>&1; then
        echo "ERROR: Task not found: $task_id" >&2
        exit 1
    fi

    # Create archive entry and remove from active
    echo "$state" | jq \
        --arg id "$task_id" \
        --arg ts "$(iso_timestamp)" \
        '.archived_tasks += [{
            "task_id": $id,
            "workflow_type": .active_tasks[$id].workflow_type,
            "completed_at": (.active_tasks[$id].completed_at // $ts),
            "status": .active_tasks[$id].status
         }]
         | del(.active_tasks[$id])
         | .resource_locks = (.resource_locks | to_entries | map(select(.value != $id)) | from_entries)' | save_state

    echo "OK"
}

cmd_list_tasks() {
    init_state
    get_state | jq '.active_tasks'
}

# ============================================================
# LOCK OPERATIONS
# ============================================================

cmd_lock() {
    local resource="$1"
    local task_id="$2"

    init_state
    local state
    state=$(get_state)

    # Check if already locked by another task
    local owner
    owner=$(echo "$state" | jq -r ".resource_locks[\"$resource\"] // \"\"")

    if [[ -n "$owner" && "$owner" != "$task_id" ]]; then
        echo "LOCKED:$owner"
        exit 1
    fi

    # Already own lock or not locked - acquire
    echo "$state" | jq \
        --arg resource "$resource" \
        --arg task_id "$task_id" \
        '.resource_locks[$resource] = $task_id' | save_state

    echo "OK"
}

cmd_release() {
    local resource="$1"
    local task_id="$2"

    local state
    state=$(get_state)

    local owner
    owner=$(echo "$state" | jq -r ".resource_locks[\"$resource\"] // \"\"")

    if [[ -z "$owner" ]]; then
        echo "OK"  # Not locked
        exit 0
    fi

    if [[ "$owner" != "$task_id" ]]; then
        echo "ERROR: Cannot release lock owned by: $owner" >&2
        exit 1
    fi

    echo "$state" | jq \
        --arg resource "$resource" \
        'del(.resource_locks[$resource])' | save_state

    echo "OK"
}

cmd_force_release() {
    local resource="$1"

    local state
    state=$(get_state)

    echo "$state" | jq \
        --arg resource "$resource" \
        'del(.resource_locks[$resource])' | save_state

    echo "OK"
}

cmd_list_locks() {
    init_state
    get_state | jq '.resource_locks'
}

# ============================================================
# SCHEMA OPERATIONS
# ============================================================

cmd_get_schema() {
    init_state
    get_state | jq '.model_schema'
}

cmd_set_schema() {
    local schema_json="$1"

    local state
    state=$(get_state)

    # Validate JSON
    if ! echo "$schema_json" | jq . > /dev/null 2>&1; then
        echo "ERROR: Invalid JSON schema" >&2
        exit 1
    fi

    echo "$state" | jq \
        --argjson schema "$schema_json" \
        --arg ts "$(iso_timestamp)" \
        '.model_schema = $schema | .model_schema.last_synced = $ts' | save_state

    echo "OK"
}

# ============================================================
# MAIN
# ============================================================

show_help() {
    cat << 'EOF'
Power BI Analyst Skill - State Manager (Bash + jq)

Usage:
  state_manage.sh summary                         Show state summary
  state_manage.sh create_task "name" "workflow"   Create task, returns ID
  state_manage.sh update_stage "id" "stage"       Update current stage
  state_manage.sh complete "task_id"              Mark task completed
  state_manage.sh fail "task_id"                  Mark task failed
  state_manage.sh archive "task_id"               Archive task
  state_manage.sh list_tasks                      List active tasks
  state_manage.sh lock "path" "task_id"           Acquire lock
  state_manage.sh release "path" "task_id"        Release lock
  state_manage.sh force_release "path"            Force release lock
  state_manage.sh list_locks                      List all locks
  state_manage.sh get_schema                      Get model schema
  state_manage.sh set_schema '<json>'             Set model schema
  state_manage.sh reset                           Reset all state

Examples:
  state_manage.sh create_task "fix-yoy-calc" "evaluate"
  state_manage.sh lock "definition/tables/Sales.tmdl" "fix-yoy-calc-1734872400"
  state_manage.sh complete "fix-yoy-calc-1734872400"
EOF
}

# Check for jq
check_jq

# Parse command
ACTION="${1:-help}"
shift || true

case "$ACTION" in
    summary)
        cmd_summary
        ;;
    reset)
        cmd_reset
        ;;
    create_task)
        cmd_create_task "${1:-unnamed}" "${2:-evaluate}"
        ;;
    update_stage)
        cmd_update_stage "$1" "$2"
        ;;
    complete)
        cmd_complete "$1"
        ;;
    fail)
        cmd_fail "$1"
        ;;
    archive)
        cmd_archive "$1"
        ;;
    list_tasks)
        cmd_list_tasks
        ;;
    lock)
        cmd_lock "$1" "$2"
        ;;
    release)
        cmd_release "$1" "$2"
        ;;
    force_release)
        cmd_force_release "$1"
        ;;
    list_locks)
        cmd_list_locks
        ;;
    get_schema)
        cmd_get_schema
        ;;
    set_schema)
        cmd_set_schema "$1"
        ;;
    help|--help|-h)
        show_help
        ;;
    *)
        echo "Unknown command: $ACTION" >&2
        echo "Use 'state_manage.sh help' for usage." >&2
        exit 1
        ;;
esac
```

**jq Dependency:**

The bash script requires `jq` for JSON processing. Users on macOS/Linux should install it:

| Platform | Command |
|----------|---------|
| macOS (Homebrew) | `brew install jq` |
| Ubuntu/Debian | `sudo apt-get install jq` |
| Alpine Linux | `apk add jq` |
| Fedora/RHEL | `sudo dnf install jq` |

---

## 4. Telemetry Addon

### 4.1 Addon Structure

```
.claude/
└── skills/
    └── powerbi-analyst/
        ├── SKILL.md                    # Core skill (always loaded)
        └── addons/
            ├── README.md               # How to enable addons
            ├── telemetry.md            # OTEL tracing addon
            └── advanced-validation.md  # Pydantic validation addon
```

### 4.2 Addon README

Location: `.claude/skills/powerbi-analyst/addons/README.md`

```markdown
# Power BI Analyst Skill - Addons

Addons extend the core skill with optional features that require additional dependencies.

## Available Addons

| Addon | Purpose | Dependencies |
|-------|---------|--------------|
| `telemetry.md` | OpenTelemetry tracing | Python 3.10+, opentelemetry-sdk |
| `advanced-validation.md` | Pydantic schema validation | Python 3.10+, pydantic |

## Enabling an Addon

### Method 1: Copy to Active Location

Copy the addon file to the skill root:

```bash
copy .claude\skills\powerbi-analyst\addons\telemetry.md ^
     .claude\skills\powerbi-analyst\telemetry.md
```

### Method 2: Configuration Flag

Add to `.claude/settings.json`:

```json
{
  "skills": {
    "powerbi-analyst": {
      "addons": ["telemetry", "advanced-validation"]
    }
  }
}
```

### Method 3: Slash Command

```
/power-bi-assistant --configure
```

Then select "Enable addons" from the menu.

## Addon Dependencies

Before enabling an addon, install its dependencies:

### telemetry.md
```bash
pip install opentelemetry-sdk opentelemetry-exporter-otlp arize-phoenix
```

### advanced-validation.md
```bash
pip install pydantic>=2.0.0
```

## Disabling an Addon

Remove the addon file from the skill root, or remove it from the `addons` array in settings.json.
```

### 4.3 Telemetry Addon Definition

Location: `.claude/skills/powerbi-analyst/addons/telemetry.md`

```markdown
---
name: powerbi-analyst-telemetry
extends: powerbi-analyst
version: 1.0.0
requires:
  python: ">=3.10"
  packages:
    - opentelemetry-sdk>=1.20.0
    - opentelemetry-exporter-otlp>=1.20.0
    - arize-phoenix>=4.0.0
---

# Telemetry Addon

This addon enables OpenTelemetry (OTEL) tracing for the Power BI Analyst skill.
Traces are exported to a local Arize Phoenix dashboard for visualization.

## Prerequisites

1. **Install Python packages:**
   ```bash
   pip install opentelemetry-sdk opentelemetry-exporter-otlp arize-phoenix
   ```

2. **Start Phoenix server:**
   ```bash
   python -m phoenix.server.main serve
   ```

   Dashboard available at: http://localhost:6006

## Configuration

The addon reads configuration from environment variables or `.claude/telemetry.json`:

```json
{
  "enabled": true,
  "endpoint": "http://localhost:6006/v1/traces",
  "service_name": "powerbi-analyst-skill",
  "sample_rate": 1.0
}
```

## Instrumentation Points

When this addon is active, the skill wraps operations with trace spans:

### Workflow Spans

Each workflow execution creates a root span:

```
powerbi-analyst.workflow
├── workflow.type: evaluate|create|implement|merge
├── workflow.task_id: <task_id>
├── mcp.mode: full|fallback
└── duration_ms: <elapsed>
```

### Agent Spans

Sub-agent invocations create child spans:

```
powerbi-analyst.agent.dax_specialist
├── agent.name: powerbi-dax-specialist
├── artifacts.count: 2
├── validation.status: passed|failed
└── duration_ms: <elapsed>
```

### MCP Operation Spans

MCP tool calls create leaf spans:

```
powerbi-analyst.mcp.measure_operations.create
├── mcp.tool: measure_operations.create
├── mcp.table: Sales
├── mcp.measure: YoY Growth
└── duration_ms: <elapsed>
```

## Usage in Skill

When this addon is detected, the orchestrator should:

### Before Workflow Start

```bash
python .claude/tools/telemetry/start_trace.py \
  --workflow "<workflow_type>" \
  --task_id "<task_id>" \
  --mcp_mode "<full|fallback>"
```

### Before Agent Invocation

```bash
python .claude/tools/telemetry/start_span.py \
  --parent_id "<workflow_trace_id>" \
  --agent "<agent_name>" \
  --task_id "<task_id>"
```

### After Agent Completion

```bash
python .claude/tools/telemetry/end_span.py \
  --span_id "<span_id>" \
  --status "<success|error>" \
  --artifacts_count "<count>"
```

### After Workflow Completion

```bash
python .claude/tools/telemetry/end_trace.py \
  --trace_id "<trace_id>" \
  --status "<success|error>"
```

## Telemetry Python Scripts

Location: `.claude/tools/telemetry/`

### start_trace.py

```python
#!/usr/bin/env python3
"""Start a new trace for a workflow execution."""

import argparse
import json
from datetime import datetime
from pathlib import Path

from opentelemetry import trace
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from opentelemetry.exporter.otlp.proto.http.trace_exporter import OTLPSpanExporter

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--workflow", required=True)
    parser.add_argument("--task_id", required=True)
    parser.add_argument("--mcp_mode", default="unknown")
    args = parser.parse_args()

    # Load config
    config_path = Path(".claude/telemetry.json")
    if config_path.exists():
        config = json.loads(config_path.read_text())
    else:
        config = {
            "endpoint": "http://localhost:6006/v1/traces",
            "service_name": "powerbi-analyst-skill"
        }

    # Initialize tracer
    provider = TracerProvider()
    exporter = OTLPSpanExporter(endpoint=config["endpoint"])
    provider.add_span_processor(BatchSpanProcessor(exporter))
    trace.set_tracer_provider(provider)

    tracer = trace.get_tracer(config["service_name"])

    # Start root span
    with tracer.start_as_current_span("powerbi-analyst.workflow") as span:
        span.set_attribute("workflow.type", args.workflow)
        span.set_attribute("workflow.task_id", args.task_id)
        span.set_attribute("mcp.mode", args.mcp_mode)
        span.set_attribute("workflow.started_at", datetime.utcnow().isoformat())

        # Store trace context for child spans
        context = {
            "trace_id": format(span.get_span_context().trace_id, "032x"),
            "span_id": format(span.get_span_context().span_id, "016x"),
            "task_id": args.task_id
        }

        context_path = Path(f".claude/tasks/{args.task_id}/trace_context.json")
        context_path.parent.mkdir(parents=True, exist_ok=True)
        context_path.write_text(json.dumps(context, indent=2))

        print(json.dumps(context))

if __name__ == "__main__":
    main()
```

## Viewing Traces

1. Open Phoenix dashboard: http://localhost:6006
2. Navigate to "Traces" tab
3. Filter by service: `powerbi-analyst-skill`
4. Click on a trace to see the span hierarchy

## Disabling Telemetry

To disable telemetry:

1. Delete or rename this addon file
2. Or set in `.claude/telemetry.json`:
   ```json
   {"enabled": false}
   ```
```

---

## 5. Compatibility Header

### 5.1 SKILL.md Header for Future Tools

Add to the beginning of `SKILL.md`:

```yaml
---
name: powerbi-analyst
version: 1.0.0
description: |
  Expert Power BI development assistant for semantic model editing,
  dashboard analysis, and report generation. Uses Microsoft's Power BI
  Modeling MCP when available, with automatic fallback to file-based
  operations.

# ============================================================
# COMPATIBILITY DECLARATION
# ============================================================
# This section declares the skill's requirements and fallback
# strategies, enabling future tools (Copilot, etc.) to adapt.

compatibility:
  # Minimum tool versions
  claude_code: ">=1.0.0"
  copilot: "experimental"      # Future support

  # Required capabilities for core functionality
  capabilities_required:
    - name: file_read
      description: Read file contents
      claude_code_tool: Read
      fallback: null  # No fallback, must have this

    - name: file_write
      description: Write file contents
      claude_code_tool: Write
      fallback: null

    - name: shell_execute
      description: Execute shell commands
      claude_code_tool: Bash
      fallback: null

  # Optional capabilities that enhance functionality
  capabilities_optional:
    - name: file_edit
      description: Edit file with find/replace
      claude_code_tool: Edit
      fallback: file_write  # Can use write as fallback

    - name: web_fetch
      description: Fetch web content
      claude_code_tool: WebFetch
      fallback: null  # Just skip documentation lookup

    - name: task_spawn
      description: Spawn sub-agent tasks
      claude_code_tool: Task
      fallback: inline  # Execute inline instead of spawning

  # State management strategy
  state_management:
    preferred: claude_native
    description: Use file_read + file_write for JSON state
    fallbacks:
      - backend: powershell
        test_command: "powershell -Command \"Write-Output 'OK'\""
        script: .claude/tools/state_manage.ps1

      - backend: cmd
        test_command: "cmd /c \"echo OK\""
        script: .claude/tools/state_manage.cmd

      - backend: bash
        test_command: "bash -c \"echo OK\""
        script: .claude/tools/state_manage.sh
        requires: jq  # For JSON parsing

# ============================================================
# TRIGGERS
# ============================================================
triggers:
  keywords:
    - "Power BI"
    - "DAX"
    - "measure"
    - "PBIX"
    - "PBIP"
    - "semantic model"

  file_patterns:
    - "*.pbip"
    - "*.pbix"
    - "*.tmdl"
    - "*/.SemanticModel/**"
    - "*/.Report/**"

# ============================================================
# MCP DEPENDENCIES
# ============================================================
mcp_dependencies:
  required: false  # Skill works without MCP (fallback mode)
  preferred:
    - name: powerbi-modeling
      source: https://github.com/microsoft/powerbi-modeling-mcp

  optional:
    - name: playwright
      purpose: Browser-based dashboard testing
---
```

### 5.2 Runtime Capability Check

Add this section to SKILL.md:

```markdown
## Initialization: Capability Detection

On first invocation each session, perform capability detection:

### Step 1: Check Tool Availability

For each required capability, verify the tool exists:

```
CHECK: file_read
  → Try: Read .claude/SKILL.md (first 10 lines)
  → If fails: ABORT - "This skill requires file reading capability"

CHECK: file_write
  → Try: Write .claude/capability_test.txt with content "test"
  → If fails: ABORT - "This skill requires file writing capability"

CHECK: shell_execute
  → Try: Bash "echo OK"
  → If fails: ABORT - "This skill requires shell execution capability"
```

### Step 2: Detect State Management Backend

```
TEST: claude_native
  → Create .claude/probe.json with {"test": true}
  → Read it back
  → Modify and write
  → Verify modification
  → If all pass: state_backend = "claude_native"
  → If any fail: continue to next test

TEST: powershell
  → Execute: powershell -Command "Write-Output 'OK'"
  → If returns "OK": state_backend = "powershell"
  → If fails: continue to next test

TEST: cmd
  → Execute: cmd /c "echo OK"
  → If returns "OK": state_backend = "cmd"
  → If fails: state_backend = "none" → WARN user
```

### Step 3: Check MCP Availability

```
TEST: mcp
  → Check if mcp__powerbi-modeling__* tools exist
  → If yes: mcp_available = true
  → If no: mcp_available = false → WARN about reduced functionality
```

### Step 4: Store Results

Write to `.claude/state.json`:

```json
{
  "session": {
    "started": "<timestamp>",
    "state_backend": "claude_native|powershell|cmd",
    "mcp_available": true|false,
    "capabilities": {
      "file_read": true,
      "file_write": true,
      "file_edit": true|false,
      "task_spawn": true|false
    }
  }
}
```

### Step 5: Display Status

```
Power BI Analyst Skill v1.0.0

Session initialized:
  State Backend: claude_native
  MCP Available: Yes
  Capabilities: file_read, file_write, file_edit, task_spawn

Ready for commands. Type your request or say "help" for options.
```
```

---

## 6. Updated Distribution Structure

### 6.1 Revised Zip Contents

```
powerbi-analyst-skill-v1.0.0.zip
│
├── install.bat                          # One-click installer (no Python)
├── install.ps1                          # PowerShell installer alternative
├── MANUAL_SETUP.md                      # Step-by-step manual guide
├── README.txt                           # Overview
│
├── payload/
│   └── .claude/
│       ├── skills/
│       │   └── powerbi-analyst/
│       │       ├── SKILL.md             # Main skill (with compatibility header)
│       │       └── addons/
│       │           ├── README.md
│       │           ├── telemetry.md
│       │           └── advanced-validation.md
│       │
│       ├── agents/
│       │   ├── powerbi-dax-specialist.md
│       │   ├── powerbi-mcode-specialist.md
│       │   └── ... (other agents)
│       │
│       └── tools/
│           ├── state_manage.ps1         # PowerShell state manager (Windows)
│           ├── state_manage.cmd         # CMD minimal fallback (Windows)
│           ├── state_manage.sh          # Bash + jq fallback (macOS/Linux)
│           └── telemetry/               # Optional Python scripts
│               ├── requirements.txt
│               ├── start_trace.py
│               ├── end_trace.py
│               └── ...
│
└── optional/
    └── telemetry-setup.bat              # Separate installer for telemetry
```

### 6.2 Revised install.bat (No Python)

```batch
@echo off
setlocal enabledelayedexpansion

echo ============================================================
echo  Power BI Analyst Skill - Quick Installer
echo  Version 1.0.0
echo ============================================================
echo.

REM ============================================================
REM Step 1: Verify PowerShell is available
REM ============================================================
echo [1/4] Checking system requirements...

powershell -Command "Write-Host 'PowerShell OK'" >nul 2>&1
if errorlevel 1 (
    echo.
    echo [ERROR] PowerShell is required but not responding.
    echo This is unusual for Windows 10/11. Please check your system.
    echo.
    pause
    exit /b 1
)
echo       PowerShell: OK

REM ============================================================
REM Step 2: Detect Power BI Modeling MCP
REM ============================================================
echo [2/4] Detecting Power BI Modeling MCP...

set MCP_FOUND=0
set MCP_PATH=

REM Check common installation paths
for %%p in (
    "%ProgramFiles%\PowerBI Modeling MCP\powerbi-modeling-mcp.exe"
    "%LOCALAPPDATA%\Programs\PowerBI-MCP\powerbi-modeling-mcp.exe"
    "%USERPROFILE%\.vscode\extensions\microsoft.powerbi-modeling-mcp-*\bin\powerbi-modeling-mcp.exe"
) do (
    if exist "%%~p" (
        set MCP_FOUND=1
        set MCP_PATH=%%~p
    )
)

if %MCP_FOUND%==0 (
    echo.
    echo [WARNING] Power BI Modeling MCP not found.
    echo.
    echo The MCP enables live semantic model editing. Without it,
    echo the skill will operate in file-based fallback mode.
    echo.
    echo Download the MCP from:
    echo   https://github.com/microsoft/powerbi-modeling-mcp/releases
    echo.
    echo Recommended install location:
    echo   C:\Program Files\PowerBI Modeling MCP\
    echo.

    choice /C YN /M "Open download page now"
    if !errorlevel!==1 (
        start https://github.com/microsoft/powerbi-modeling-mcp/releases
        echo.
        echo After installing the MCP, run this installer again.
        pause
        exit /b 0
    )

    echo.
    echo Continuing without MCP (file-based mode)...
    echo.
) else (
    echo       MCP Found: !MCP_PATH!
)

REM ============================================================
REM Step 3: Copy skill files
REM ============================================================
echo [3/4] Installing skill files...

if not exist "payload\.claude" (
    echo [ERROR] payload\.claude folder not found.
    echo Please run this installer from the extracted zip folder.
    pause
    exit /b 1
)

xcopy /E /I /Y "payload\.claude" ".claude" >nul
if errorlevel 1 (
    echo [ERROR] Failed to copy skill files.
    pause
    exit /b 1
)
echo       Skill files copied to .claude\

REM ============================================================
REM Step 4: Configure Claude Desktop (if MCP found)
REM ============================================================
echo [4/4] Configuring Claude Desktop...

if %MCP_FOUND%==1 (
    powershell -ExecutionPolicy Bypass -Command ^
        "$configPath = \"$env:APPDATA\Claude\claude_desktop_config.json\"; ^
        if (Test-Path $configPath) { ^
            $config = Get-Content $configPath | ConvertFrom-Json; ^
        } else { ^
            $config = @{mcpServers = @{}}; ^
        } ^
        $config.mcpServers | Add-Member -Force -Name 'powerbi-modeling' -Value @{ ^
            command = '!MCP_PATH!'; ^
            args = @(); ^
            env = @{} ^
        } -MemberType NoteProperty; ^
        $config | ConvertTo-Json -Depth 10 | Set-Content $configPath; ^
        Write-Host '       MCP configured in Claude Desktop'"
) else (
    echo       Skipped MCP configuration (not installed)
)

REM ============================================================
REM Complete!
REM ============================================================
echo.
echo ============================================================
echo  SUCCESS! Installation complete.
echo ============================================================
echo.
echo Next steps:
echo   1. Restart Claude Desktop
echo   2. Open a Power BI project folder
echo   3. Type: /power-bi-assistant
echo.

if %MCP_FOUND%==0 (
    echo NOTE: Running in file-based mode. For full functionality,
    echo install the Power BI Modeling MCP and run this installer again.
    echo.
)

echo Optional: Enable telemetry addon
echo   Run: optional\telemetry-setup.bat
echo.

pause
```

---

## 7. Summary of Changes

### Removed from Core

| Item | Reason |
|------|--------|
| Python 3.10+ requirement | Replaced by Claude-native + PowerShell |
| state_manage.py | Replaced by state_manage.ps1 |
| requirements.txt (core) | Moved to optional addons |
| pydantic dependency | Moved to optional addon |
| Telemetry prompts in installer | Moved to separate addon |

### Added

| Item | Purpose |
|------|---------|
| Capability detection protocol | Determine best state backend |
| state_manage.ps1 | PowerShell fallback for state (Windows) |
| state_manage.cmd | CMD minimal fallback (Windows) |
| state_manage.sh | Bash + jq fallback (macOS/Linux) |
| Compatibility header in SKILL.md | Future tool support |
| Addons folder structure | Optional Python enhancements |
| telemetry.md addon | OTEL tracing (Python required) |

### Modified

| Item | Change |
|------|--------|
| install.bat | Removed Python/pip steps |
| Distribution zip | Restructured with optional/ folder |
| State schema | Added capability_probe section |
| Findings template | Added backend indicator |

---

## 8. Migration Notes

### For Existing Users

If upgrading from a Python-based installation:

1. The old `state_manage.py` still works but is deprecated
2. New installations will use Claude-native or PowerShell
3. Existing state.json files are compatible
4. Telemetry users should install the addon separately

### For Developers

1. All state operations should go through the documented protocols
2. Test with all three backends (claude_native, powershell, cmd)
3. Addons should declare their dependencies explicitly
4. Future tools should check the compatibility header
