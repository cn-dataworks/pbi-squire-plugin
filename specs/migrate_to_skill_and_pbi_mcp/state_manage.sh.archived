#!/usr/bin/env bash
#
# Power BI Analyst Skill - State Manager (Bash + jq Fallback)
#
# Used when Claude-native JSON operations and PowerShell are not available.
# Requires: jq (JSON processor)
#
# Usage:
#   state_manage.sh summary                       - Show state summary
#   state_manage.sh create_task "name" "workflow" - Create new task
#   state_manage.sh update_stage "task_id" "stage" - Update task stage
#   state_manage.sh complete "task_id"            - Mark task completed
#   state_manage.sh fail "task_id"                - Mark task failed
#   state_manage.sh archive "task_id"             - Archive task
#   state_manage.sh list_tasks                    - List active tasks
#   state_manage.sh lock "path" "task_id"         - Acquire lock
#   state_manage.sh release "path" "task_id"      - Release lock
#   state_manage.sh list_locks                    - List all locks
#   state_manage.sh get_schema                    - Get model schema
#   state_manage.sh reset                         - Reset all state
#

set -euo pipefail

# Configuration
STATE_PATH=".claude/state.json"
TASKS_DIR=".claude/tasks"

# ============================================================
# HELPER FUNCTIONS
# ============================================================

check_jq() {
    if ! command -v jq &> /dev/null; then
        echo "ERROR: jq is required but not installed."
        echo "Install jq:"
        echo "  macOS:   brew install jq"
        echo "  Ubuntu:  sudo apt-get install jq"
        echo "  Alpine:  apk add jq"
        exit 1
    fi
}

iso_timestamp() {
    date -u +"%Y-%m-%dT%H:%M:%SZ"
}

unix_timestamp() {
    date +%s
}

sanitize_name() {
    echo "$1" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g' | sed 's/-\+/-/g'
}

# Initialize state file if it doesn't exist
init_state() {
    mkdir -p "$(dirname "$STATE_PATH")"

    if [[ ! -f "$STATE_PATH" ]]; then
        cat > "$STATE_PATH" << EOF
{
  "session": {
    "started": "$(iso_timestamp)",
    "last_activity": "$(iso_timestamp)",
    "skill_version": "1.0.0",
    "state_backend": "bash",
    "mcp_available": false
  },
  "model_schema": {
    "tables": [],
    "relationships": []
  },
  "active_tasks": {},
  "resource_locks": {},
  "archived_tasks": []
}
EOF
    fi
}

# Get state JSON
get_state() {
    init_state
    cat "$STATE_PATH"
}

# Save state JSON (expects JSON on stdin)
save_state() {
    # Update last_activity timestamp
    jq --arg ts "$(iso_timestamp)" '.session.last_activity = $ts' > "$STATE_PATH.tmp"
    mv "$STATE_PATH.tmp" "$STATE_PATH"
}

# ============================================================
# SESSION OPERATIONS
# ============================================================

cmd_summary() {
    init_state
    local state
    state=$(get_state)

    local started last_activity backend mcp_avail task_count lock_count archive_count
    started=$(echo "$state" | jq -r '.session.started // "unknown"')
    last_activity=$(echo "$state" | jq -r '.session.last_activity // "unknown"')
    backend=$(echo "$state" | jq -r '.session.state_backend // "bash"')
    mcp_avail=$(echo "$state" | jq -r '.session.mcp_available // false')
    task_count=$(echo "$state" | jq '.active_tasks | length')
    lock_count=$(echo "$state" | jq '.resource_locks | length')
    archive_count=$(echo "$state" | jq '.archived_tasks | length')

    cat << EOF
{
  "session_started": "$started",
  "last_activity": "$last_activity",
  "state_backend": "$backend",
  "mcp_available": $mcp_avail,
  "active_task_count": $task_count,
  "lock_count": $lock_count,
  "archived_count": $archive_count
}
EOF
}

cmd_reset() {
    if [[ -f "$STATE_PATH" ]]; then
        rm -f "$STATE_PATH"
    fi
    echo "State reset complete"
}

# ============================================================
# TASK OPERATIONS
# ============================================================

cmd_create_task() {
    local name="$1"
    local workflow="${2:-evaluate}"

    init_state

    local sanitized task_id task_path timestamp
    sanitized=$(sanitize_name "$name")
    timestamp=$(unix_timestamp)
    task_id="${sanitized}-${timestamp}"
    task_path="${TASKS_DIR}/${task_id}"

    # Create task directory
    mkdir -p "$task_path"

    # Create findings.md
    cat > "${task_path}/findings.md" << EOF
# Task Blackboard: $name

**Status:** in_progress
**Task ID:** $task_id
**Workflow:** $workflow
**Created:** $(iso_timestamp)
**Backend:** bash

---

## Section 1: Requirements
*Pending...*
EOF

    # Update state
    local state
    state=$(get_state)

    echo "$state" | jq \
        --arg id "$task_id" \
        --arg path "$task_path" \
        --arg workflow "$workflow" \
        --arg created "$(iso_timestamp)" \
        '.active_tasks[$id] = {
            "path": $path,
            "status": "in_progress",
            "workflow_type": $workflow,
            "created": $created,
            "updated": $created,
            "current_stage": "init"
        }' | save_state

    echo "$task_id"
}

cmd_update_stage() {
    local task_id="$1"
    local stage="$2"

    local state
    state=$(get_state)

    # Check if task exists
    if ! echo "$state" | jq -e ".active_tasks[\"$task_id\"]" > /dev/null 2>&1; then
        echo "ERROR: Task not found: $task_id" >&2
        exit 1
    fi

    echo "$state" | jq \
        --arg id "$task_id" \
        --arg stage "$stage" \
        --arg ts "$(iso_timestamp)" \
        '.active_tasks[$id].current_stage = $stage | .active_tasks[$id].updated = $ts' | save_state

    echo "OK"
}

cmd_complete() {
    local task_id="$1"

    local state
    state=$(get_state)

    # Check if task exists
    if ! echo "$state" | jq -e ".active_tasks[\"$task_id\"]" > /dev/null 2>&1; then
        echo "ERROR: Task not found: $task_id" >&2
        exit 1
    fi

    # Mark complete and release locks
    echo "$state" | jq \
        --arg id "$task_id" \
        --arg ts "$(iso_timestamp)" \
        '.active_tasks[$id].status = "completed"
         | .active_tasks[$id].completed_at = $ts
         | .resource_locks = (.resource_locks | to_entries | map(select(.value != $id)) | from_entries)' | save_state

    echo "OK"
}

cmd_fail() {
    local task_id="$1"

    local state
    state=$(get_state)

    # Check if task exists
    if ! echo "$state" | jq -e ".active_tasks[\"$task_id\"]" > /dev/null 2>&1; then
        echo "ERROR: Task not found: $task_id" >&2
        exit 1
    fi

    echo "$state" | jq \
        --arg id "$task_id" \
        --arg ts "$(iso_timestamp)" \
        '.active_tasks[$id].status = "failed" | .active_tasks[$id].failed_at = $ts' | save_state

    echo "OK"
}

cmd_archive() {
    local task_id="$1"

    local state
    state=$(get_state)

    # Check if task exists
    if ! echo "$state" | jq -e ".active_tasks[\"$task_id\"]" > /dev/null 2>&1; then
        echo "ERROR: Task not found: $task_id" >&2
        exit 1
    fi

    # Create archive entry and remove from active
    echo "$state" | jq \
        --arg id "$task_id" \
        --arg ts "$(iso_timestamp)" \
        '.archived_tasks += [{
            "task_id": $id,
            "workflow_type": .active_tasks[$id].workflow_type,
            "completed_at": (.active_tasks[$id].completed_at // $ts),
            "status": .active_tasks[$id].status
         }]
         | del(.active_tasks[$id])
         | .resource_locks = (.resource_locks | to_entries | map(select(.value != $id)) | from_entries)' | save_state

    echo "OK"
}

cmd_list_tasks() {
    init_state
    get_state | jq '.active_tasks'
}

# ============================================================
# LOCK OPERATIONS
# ============================================================

cmd_lock() {
    local resource="$1"
    local task_id="$2"

    init_state
    local state
    state=$(get_state)

    # Check if already locked by another task
    local owner
    owner=$(echo "$state" | jq -r ".resource_locks[\"$resource\"] // \"\"")

    if [[ -n "$owner" && "$owner" != "$task_id" ]]; then
        echo "LOCKED:$owner"
        exit 1
    fi

    # Already own lock or not locked - acquire
    echo "$state" | jq \
        --arg resource "$resource" \
        --arg task_id "$task_id" \
        '.resource_locks[$resource] = $task_id' | save_state

    echo "OK"
}

cmd_release() {
    local resource="$1"
    local task_id="$2"

    local state
    state=$(get_state)

    local owner
    owner=$(echo "$state" | jq -r ".resource_locks[\"$resource\"] // \"\"")

    if [[ -z "$owner" ]]; then
        echo "OK"  # Not locked
        exit 0
    fi

    if [[ "$owner" != "$task_id" ]]; then
        echo "ERROR: Cannot release lock owned by: $owner" >&2
        exit 1
    fi

    echo "$state" | jq \
        --arg resource "$resource" \
        'del(.resource_locks[$resource])' | save_state

    echo "OK"
}

cmd_force_release() {
    local resource="$1"

    local state
    state=$(get_state)

    echo "$state" | jq \
        --arg resource "$resource" \
        'del(.resource_locks[$resource])' | save_state

    echo "OK"
}

cmd_list_locks() {
    init_state
    get_state | jq '.resource_locks'
}

# ============================================================
# SCHEMA OPERATIONS
# ============================================================

cmd_get_schema() {
    init_state
    get_state | jq '.model_schema'
}

cmd_set_schema() {
    local schema_json="$1"

    local state
    state=$(get_state)

    # Validate JSON
    if ! echo "$schema_json" | jq . > /dev/null 2>&1; then
        echo "ERROR: Invalid JSON schema" >&2
        exit 1
    fi

    echo "$state" | jq \
        --argjson schema "$schema_json" \
        --arg ts "$(iso_timestamp)" \
        '.model_schema = $schema | .model_schema.last_synced = $ts' | save_state

    echo "OK"
}

# ============================================================
# MAIN
# ============================================================

show_help() {
    cat << 'EOF'
Power BI Analyst Skill - State Manager (Bash + jq)

Usage:
  state_manage.sh summary                         Show state summary
  state_manage.sh create_task "name" "workflow"   Create task, returns ID
  state_manage.sh update_stage "id" "stage"       Update current stage
  state_manage.sh complete "task_id"              Mark task completed
  state_manage.sh fail "task_id"                  Mark task failed
  state_manage.sh archive "task_id"               Archive task
  state_manage.sh list_tasks                      List active tasks
  state_manage.sh lock "path" "task_id"           Acquire lock
  state_manage.sh release "path" "task_id"        Release lock
  state_manage.sh force_release "path"            Force release lock
  state_manage.sh list_locks                      List all locks
  state_manage.sh get_schema                      Get model schema
  state_manage.sh set_schema '<json>'             Set model schema
  state_manage.sh reset                           Reset all state

Examples:
  state_manage.sh create_task "fix-yoy-calc" "evaluate"
  state_manage.sh lock "definition/tables/Sales.tmdl" "fix-yoy-calc-1734872400"
  state_manage.sh complete "fix-yoy-calc-1734872400"
EOF
}

# Check for jq
check_jq

# Parse command
ACTION="${1:-help}"
shift || true

case "$ACTION" in
    summary)
        cmd_summary
        ;;
    reset)
        cmd_reset
        ;;
    create_task)
        cmd_create_task "${1:-unnamed}" "${2:-evaluate}"
        ;;
    update_stage)
        cmd_update_stage "$1" "$2"
        ;;
    complete)
        cmd_complete "$1"
        ;;
    fail)
        cmd_fail "$1"
        ;;
    archive)
        cmd_archive "$1"
        ;;
    list_tasks)
        cmd_list_tasks
        ;;
    lock)
        cmd_lock "$1" "$2"
        ;;
    release)
        cmd_release "$1" "$2"
        ;;
    force_release)
        cmd_force_release "$1"
        ;;
    list_locks)
        cmd_list_locks
        ;;
    get_schema)
        cmd_get_schema
        ;;
    set_schema)
        cmd_set_schema "$1"
        ;;
    help|--help|-h)
        show_help
        ;;
    *)
        echo "Unknown command: $ACTION" >&2
        echo "Use 'state_manage.sh help' for usage." >&2
        exit 1
        ;;
esac
