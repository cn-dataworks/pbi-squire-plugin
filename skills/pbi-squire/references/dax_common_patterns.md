# Common DAX Patterns - Business Language Translation

This reference helps translate common DAX patterns into clear business language.

## Aggregation Patterns

### SUM / SUMX

**Technical Pattern**:
```dax
Total Sales = SUM(Sales[Amount])
Total Sales = SUMX(Sales, Sales[Quantity] * Sales[Price])
```

**Business Translation**:
"Sums up all [column name] values"
"Calculates total by multiplying [X] × [Y] for each row and summing the results"

**Example**:
- **Measure**: Total Revenue
- **Definition**: Sums up all invoice amounts from the Sales table
- **Dependencies**: Sales[Amount] (column)

---

### COUNT / COUNTROWS / DISTINCTCOUNT

**Technical Pattern**:
```dax
Order Count = COUNTROWS(Orders)
Customer Count = DISTINCTCOUNT(Sales[CustomerID])
```

**Business Translation**:
"Counts the number of [entities]"
"Counts unique [entities]"

**Example**:
- **Measure**: Active Customers
- **Definition**: Counts unique customer IDs with at least one order
- **Dependencies**: Sales[CustomerID] (column)

---

### AVERAGE / AVERAGEX

**Technical Pattern**:
```dax
Avg Order Value = AVERAGE(Orders[Amount])
Avg Order Value = AVERAGEX(Orders, Orders[Quantity] * Orders[Price])
```

**Business Translation**:
"Calculates the average [metric]"
"Averages the calculated [expression] across all rows"

---

### MIN / MAX

**Technical Pattern**:
```dax
Earliest Date = MIN(Sales[OrderDate])
Max Revenue = MAX(Sales[Amount])
```

**Business Translation**:
"Finds the earliest/latest [date/time]"
"Finds the minimum/maximum [value]"

---

## Time Intelligence Patterns

### Year-over-Year (YoY) Comparison

**Technical Pattern**:
```dax
Prior Year Sales = CALCULATE([Total Sales], SAMEPERIODLASTYEAR(Calendar[Date]))

YoY Growth = [Total Sales] - [Prior Year Sales]

YoY Growth % = DIVIDE([YoY Growth], [Prior Year Sales], 0)
```

**Business Translation**:
"Compares current period performance to the same period last year"

**Example**:
- **Measure**: YoY Revenue Growth %
- **Definition**: Shows the percentage increase or decrease in revenue compared to the same period last year. Returns 0% if there were no sales in the prior period.
- **Dependencies**: Total Sales, Prior Year Sales
- **Business Logic**: Calculates (Current Sales - Prior Year Sales) / Prior Year Sales

---

### Month-over-Month (MoM) Comparison

**Technical Pattern**:
```dax
Prior Month Sales = CALCULATE([Total Sales], DATEADD(Calendar[Date], -1, MONTH))

MoM Growth % = DIVIDE([Total Sales] - [Prior Month Sales], [Prior Month Sales], 0)
```

**Business Translation**:
"Compares current month performance to the previous month"

---

### Year-to-Date (YTD) / Quarter-to-Date (QTD)

**Technical Pattern**:
```dax
YTD Sales = TOTALYTD([Total Sales], Calendar[Date])
QTD Sales = TOTALQTD([Total Sales], Calendar[Date])
```

**Business Translation**:
"Calculates cumulative [metric] from the beginning of the year/quarter to the current date"

**Example**:
- **Measure**: YTD Revenue
- **Definition**: Cumulative revenue from January 1st through the current date
- **Dependencies**: Total Sales, Calendar[Date]

---

### Rolling/Moving Average

**Technical Pattern**:
```dax
Rolling 3M Avg =
CALCULATE(
    AVERAGE(Sales[Amount]),
    DATESINPERIOD(Calendar[Date], LASTDATE(Calendar[Date]), -3, MONTH)
)
```

**Business Translation**:
"Calculates the average [metric] over the past [N] [days/months/years]"

**Example**:
- **Measure**: 3-Month Rolling Average Sales
- **Definition**: Average monthly sales over the past 3 months, updated continuously
- **Business Logic**: Smooths out monthly fluctuations to show overall trend

---

## Filter and Conditional Patterns

### CALCULATE with Filters

**Technical Pattern**:
```dax
Online Sales = CALCULATE([Total Sales], Sales[Channel] = "Online")

High Value Orders = CALCULATE([Order Count], Sales[Amount] > 1000)
```

**Business Translation**:
"Calculates [metric] but only for records where [condition]"

**Example**:
- **Measure**: Online Revenue
- **Definition**: Total revenue from online sales channel only, excluding in-store and phone orders
- **Dependencies**: Total Sales
- **Business Logic**: Filters to only include sales where Channel = "Online"

---

### FILTER with Complex Conditions

**Technical Pattern**:
```dax
Premium Customer Sales =
CALCULATE(
    [Total Sales],
    FILTER(Customers, Customers[Tier] = "Premium" && Customers[Active] = TRUE)
)
```

**Business Translation**:
"Calculates [metric] filtered to [complex condition description]"

**Example**:
- **Measure**: Premium Active Customer Revenue
- **Definition**: Revenue generated by customers who are both in the Premium tier and currently active
- **Dependencies**: Total Sales
- **Business Logic**: Applies two filters - customer tier must be Premium AND active status must be true

---

### ALL / ALLEXCEPT (Removing Filters)

**Technical Pattern**:
```dax
% of Total Sales = DIVIDE([Total Sales], CALCULATE([Total Sales], ALL(Products)))

% of Region Sales = DIVIDE([Total Sales], CALCULATE([Total Sales], ALLEXCEPT(Sales, Sales[Region])))
```

**Business Translation**:
"Calculates [metric] as a percentage of the grand total (ignoring current filters)"
"Calculates [metric] as a percentage of [specific dimension] total"

**Example**:
- **Measure**: % of Total Revenue
- **Definition**: Shows what percentage of total company revenue this row/category represents
- **Business Logic**: Divides the current filtered revenue by total revenue across all products/regions

---

## Conditional Logic Patterns

### IF / SWITCH

**Technical Pattern**:
```dax
Order Size =
IF([Total Sales] > 10000, "Large",
IF([Total Sales] > 1000, "Medium", "Small"))

Product Category Label =
SWITCH(
    Products[CategoryID],
    1, "Electronics",
    2, "Clothing",
    3, "Home Goods",
    "Other"
)
```

**Business Translation**:
"Categorizes [entity] based on [criteria]"
"Assigns labels based on [logic]"

**Example**:
- **Calculated Column**: Customer Segment
- **Definition**: Categorizes customers into segments based on their lifetime value
- **Business Logic**:
  - "High Value" if lifetime value > $10,000
  - "Medium Value" if lifetime value $1,000-$10,000
  - "Low Value" if lifetime value < $1,000

---

### DIVIDE (Safe Division)

**Technical Pattern**:
```dax
Profit Margin % = DIVIDE([Profit], [Revenue], 0)
Avg Order Value = DIVIDE([Total Sales], [Order Count], 0)
```

**Business Translation**:
"Calculates [X] divided by [Y], returning [default] if [Y] is zero"

**Example**:
- **Measure**: Average Order Value
- **Definition**: Average revenue per order, showing $0 if there are no orders
- **Dependencies**: Total Sales, Order Count
- **Business Logic**: Safely divides total revenue by order count, avoiding division-by-zero errors

---

## Ranking and Top N Patterns

### RANKX

**Technical Pattern**:
```dax
Product Rank = RANKX(ALL(Products[Name]), [Total Sales], , DESC, DENSE)
```

**Business Translation**:
"Ranks [entities] by [metric], with 1 being the highest"

**Example**:
- **Measure**: Sales Rank
- **Definition**: Ranks products by total sales, with 1 being the top-selling product
- **Business Logic**: Ignores current filters to rank across all products

---

### TOPN

**Technical Pattern**:
```dax
Top 5 Products =
CALCULATE(
    [Total Sales],
    TOPN(5, ALL(Products), [Total Sales], DESC)
)
```

**Business Translation**:
"Calculates [metric] for only the top [N] [entities] by [ranking metric]"

---

## Relationship and Lookup Patterns

### RELATED (Many-to-One)

**Technical Pattern**:
```dax
Product Category = RELATED(Products[Category])
```

**Business Translation**:
"Looks up [column] from the related [table]"

**Example** (Calculated Column in Sales table):
- **Column**: Product Category
- **Definition**: Retrieves the category name from the Products table for each sale
- **Business Logic**: Uses the relationship between Sales and Products tables

---

### RELATEDTABLE (One-to-Many)

**Technical Pattern**:
```dax
Customer Order Count = COUNTROWS(RELATEDTABLE(Orders))
```

**Business Translation**:
"Counts/sums related records in the [detail table]"

---

### LOOKUPVALUE

**Technical Pattern**:
```dax
Manager Name = LOOKUPVALUE(Employees[Name], Employees[ID], [ManagerID])
```

**Business Translation**:
"Looks up [value] from [table] where [condition matches]"

---

## Advanced Filter Context Patterns

### KEEPFILTERS

**Technical Pattern**:
```dax
Sales Respecting Slicer =
CALCULATE(
    [Total Sales],
    KEEPFILTERS(Products[Category] = "Electronics")
)
```

**Business Translation**:
"Adds an additional filter while respecting existing filters from slicers"

---

### REMOVEFILTERS

**Technical Pattern**:
```dax
Total Company Sales = CALCULATE([Total Sales], REMOVEFILTERS(Products))
```

**Business Translation**:
"Calculates [metric] ignoring filters on [dimension]"

---

### VALUES / SELECTEDVALUE

**Technical Pattern**:
```dax
Selected Region = SELECTEDVALUE(Sales[Region], "All Regions")

Region Count = COUNTROWS(VALUES(Sales[Region]))
```

**Business Translation**:
"Returns the currently filtered/selected [value], or [default] if multiple are selected"

---

## Measure Dependency Documentation

When documenting measures, always list dependencies clearly:

**Format**:
```markdown
### [Measure Name]

- **Definition**: [Business-friendly explanation]
- **Dependencies**: [List of measures and columns this measure uses]
- **Business Logic**: [Key logic points, conditions, filters]
- **Returns**: [What type of value and format]
```

**Example**:
```markdown
### Profit Margin %

- **Definition**: Shows profit as a percentage of total revenue, indicating how much of each dollar in sales is retained as profit
- **Dependencies**:
  - Total Profit (measure)
  - Total Revenue (measure)
- **Business Logic**: Divides total profit by total revenue. Returns 0% if revenue is zero to avoid errors.
- **Returns**: Percentage formatted value (e.g., 23.5%)
```

---

## Translation Best Practices

1. **Avoid DAX jargon**: Don't say "CALCULATE with filter context modification" — say "calculates the total while filtering to specific conditions"

2. **Explain the business value**: Not just what it calculates, but why it matters

3. **Note important edge cases**: Zero division handling, missing data, filter interactions

4. **Use familiar comparisons**: "Same period last year", "running total", "top 10"

5. **Keep it concise**: One-sentence definition, then optional details

6. **Show dependencies**: Always list which other measures this depends on

7. **Explain filters clearly**: "Only includes online orders" vs technical filter syntax
